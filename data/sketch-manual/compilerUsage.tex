\section{Overview}
\seclabel{overview}

This section provides a brief tutorial on how to run a very simple example through the compiler. The sections that follow provide detailed descriptions of all language constructs. 

\subsection{Hello World}
To illustrate the process of sketching, we begin with the simplest sketch one can possibly write: the "hello world" of sketching.

\begin{lstlisting}
harness void doubleSketch(int x){
  int t = x * ??;
  assert t == x + x;
}
\end{lstlisting}

The syntax of the code fragment above should be familiar to anyone who has programmed in C or Java. The only new feature is the symbol \C{??}, which is Sketch syntax to represent an unknown constant. The synthesizer will replace this symbol with a suitable constant to satisfy the programmer's requirements. In the case of this example, the programmer's requirements are stated in the form of an assertion. The keyword \C{harness} indicates to the synthesizer that it should find a value for \C{??} that satisfies the assertion for all possible inputs \C{x}.

\flagdoc{bnd-inbits}{In practice, the solver only searches a bounded space of inputs ranging from zero to $2^{\mbox{\small{\texttt{bnd-inbits}}}}-1$. The default for this flag is 5; attempting numbers much bigger than this is not recommended.}


\subsection{Running the synthesizer}

To try this sketch out on your own, place it in a file, say \C{test1.sk}. Then, run the synthesizer with the following command line:

\begin{lstlisting}
   > sketch   test1.sk
\end{lstlisting}

When you run the synthesizer in this way, the synthesized program is simply written to the console. If instead you want the synthesizer to produce standard C code, you can run with the flag \C{--fe-output-code}. The synthesizer can even produce a test harness for the generated code, which is useful as a sanity check to make sure the generated code is behaving correctly.

\flagdoc{fe-output-code}{This flag forces the code generator to produce a C++ implementation from the sketch. Without it, the synthesizer simply outputs the code to the console}

\flagdoc{fe-output-test}{This flag causes the synthesizer to produce a test harness to run the C++ code on a set of random inputs.}

Flags can be passed to the compiler in two ways. The first and most traditional one is by passing them in the command line. For the example above, you can get code generated by invoking the compiler as follows.
\begin{lstlisting}
   > sketch   --fe-output-code test1.sk
\end{lstlisting}

An alternative way is to use the \C{pragma} construct in the language. Anywhere in the top level scope of the program, you can write the following statement:
\begin{lstlisting}
   pragma options " $flags$ ";
\end{lstlisting}
This is very useful if your sketch requires a particular set of flags to synthesize. Flags passed through the command line take precedence over flags passed with \C{pragma}, so you can always use the command line to override options embedded in the file.


\subsection{Parallel Solving}
The \Sk{} synthesizer has a parallel mode which can yield significant speedups on certain problems. Parallel mode can be invoked by running with the flag \C{--slv-parallel}. By default, this flag will use one less than the total number of processors available in your system, but you can control the exact number of processors used by passing the additional flag \C{--slv-p-cpus}. Not all problems will benefit from parallel solving; some problems will actually be slowed down because of the added overhead, but for some problems, parallelism can provide a significant performance boost. \secref{parallel} goes into the details of how to get the most from parallel execution.



\flagdoc{slv-parallel}{ This flags enables parallel mode, allowing the synthesizer to take advantage of multiple cores. By default, the synthesizer will use one less core than the total number of cores available in your system}
\flagdoc{slv-p-cpus}{ This flag can be used in combination to the \C{--slv-parallel} flag to indicate to the synthesizer how many cores to use.}  
